#!/usr/bin/env python3

import argparse
import aiohttp
import asyncio
import contextlib
from functools import wraps
import json
import logging
import os
import sys

logging.basicConfig(level=logging.DEBUG)


scenarios = {}


def scenario(f):
    @wraps(f)
    async def wrapper(*args, **kwds):
        return await f(*args, **kwds)
    scenarios[f.__name__] = f
    return wrapper


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('scenario')
    args = parser.parse_args()
    args.scenario = scenarios.get(args.scenario)
    return args


def find_socket():
    for location in ('.subiquity/socket', '/run/subiquity/socket'):
        if os.path.exists(location):
            return location
    raise ClientException('Cannot find subiquity socket')


def json_print(json_data):
    print(json.dumps(json_data, indent=4))


def loads(data):
    return json.loads(data) if data else None


def dumps(data):
    # if the data we're dumping is literally False, we want that to be 'false'
    if data or type(data) is bool:
        return json.dumps(data, separators=(',', ':'))
    elif data is not None:
        return '""'
    else:
        return data


class ClientException(Exception):
    pass


class Client:
    def __init__(self, session):
        self.session = session

    async def get(self, query, **kwargs):
        return await self.request('GET', query, **kwargs)

    async def post(self, query, data=None, **kwargs):
        return await self.request('POST', query, data, **kwargs)

    async def request(self, method, query, data=None, **kwargs):
        params = {}
        for key in kwargs:
            params[key] = dumps(kwargs[key])
        data = dumps(data)
        info = f'{method} {query}'
        if params:
            for i, key in enumerate(params):
                joiner = '?' if i == 0 else '&'
                info += f'{joiner}{key}={params[key]}'
        print(info)
        # try:
        async with self.session.request(method, f'http://a{query}',
                                        data=data, params=params) as resp:
            content = await resp.content.read()
            content = content.decode()
            if resp.status != 200:
                raise ClientException(content)
            return loads(content)
# except aiohttp.client_exceptions.ServerDisconnectedError:
#     return None


@contextlib.asynccontextmanager
async def client_factory(socket_path):
    conn = aiohttp.UnixConnector(path=socket_path)
    async with aiohttp.ClientSession(connector=conn) as session:
        yield Client(session)


async def server_startup(client):
    for _ in range(20):
        try:
            await client.get('/meta/status')
            return
        except aiohttp.client_exceptions.ClientConnectorError:
            await asyncio.sleep(.5)
    raise Exception('timeout on server startup')


async def server_shutdown(client, immediate=True):
    try:
        await client.post('/shutdown', mode='POWEROFF', immediate=immediate)
        raise Exception('expected ServerDisconnectedError')
    except aiohttp.client_exceptions.ServerDisconnectedError:
        return


async def guided(client):
    resp = await client.get('/storage/guided')
    disk_id = resp['disks'][0]['id']
    choice = {
            "disk_id": disk_id,
            "use_lvm": False,
            "password": None,
    }
    await client.post('/storage/v2/guided', choice=choice)
    await client.post('/storage/v2')


async def v2(client):
    storage_resp = await client.get('/storage/v2')
    disk = storage_resp['disks'][0]
    disk_id = disk['id']
    data = {
        'disk_id': disk_id,
        'partition': {
            'size': 0,
            'number': 4,
            'mount': '',
            'format': '',
            'annotations': None
        }
    }
    await client.post('/storage/v2/delete_partition', data)
    await client.post('/storage/v2/reformat_disk', disk_id=disk_id)
    data = {
        'disk_id': disk_id,
        'partition': {
            'size': 0,
            'number': 2,
            'mount': '/',
            'format': 'ext3',
            'annotations': None
        }
    }
    await client.post('/storage/v2/add_partition', data)
    data['partition']['format'] = 'ext4'
    await client.post('/storage/v2/edit_partition', data)
    await client.post('/storage/v2/reset')
    choice = {
        "disk_id": disk_id,
        "use_lvm": False,
        "password": None,
    }
    # json_print()
    await client.post('/storage/v2/guided', choice=choice)
    await client.post('/storage/v2')


@scenario
async def auto_server_install(client, storage=guided):
    await client.post('/locale', 'en_US.UTF-8')
    keyboard = {
        'layout': 'us',
        'variant': '',
        'toggle': None
    }
    await client.post('/keyboard', keyboard)
    await client.post('/source', source_id='ubuntu-server')
    await client.post('/network')
    await client.post('/proxy', '')
    await client.post('/mirror', 'http://us.archive.ubuntu.com/ubuntu')
    await storage(client)
    await client.get('/meta/status', cur='WAITING')
    await client.post('/meta/confirm', tty='/dev/tty1')
    await client.get('/meta/status', cur='NEEDS_CONFIRMATION')
    identity = {
        'realname': 'ubuntu',
        'username': 'ubuntu',
        'hostname': 'ubuntu-server',
        'crypted_password': '$6$exDY1mhS4KUYCE/2$zmn9ToZwTKLhCw.b4/'
                            + 'b.ZRTIZM30JZ4QrOQ2aOXJ8yk96xpcCof0kx'
                            + 'KwuX1kqLG/ygbJ1f8wxED22bTL4F46P0'
    }
    await client.post('/identity', identity)
    ssh = {
        'install_server': False,
        'allow_pw': False,
        'authorized_keys': []
    }
    await client.post('/ssh', ssh)
    await client.post('/snaplist', [])
    await client.get('/meta/status', cur='RUNNING')
    await client.get('/meta/status', cur='POST_WAIT')
    await client.get('/meta/status', cur='POST_RUNNING')
    await client.get('/meta/status', cur='UU_RUNNING')


@scenario
async def has_bitlocker(client):
    resp = await client.get('/storage/has_bitlocker')
    assert resp[0]['partitions'][2]['format'] == 'BitLocker'


async def main(args):
    async with client_factory(find_socket()) as client:
        await server_startup(client)
        await args.scenario(client)
        await server_shutdown(client)


if __name__ == "__main__":
    asyncio.run(main(get_args()))
